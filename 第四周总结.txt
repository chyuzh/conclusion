对闭包的理解

首先,在最外层声明的变量属于全局变量,在函数内声明的变量属于局部变量,

我们有时候需要一个既不会被释放掉的变量,又不想多声明全局变量污染整个环境,

于是我们可以在函数内部声明一个局部变量,然后函数内部再嵌套一个函数用来储存

这个局部变量,使其不能释放

然后,链式作用域是指函数变量对函数的内部函数是可见的,而外部是不可以获取到它的变量的,

即:父对子是可见,子对父是不可见的

如果要让外部函数读取到内部函数的变量,那么就需要在内部函数 return它的变量,这样就能让

外部函数读取到内部函数了;

对函数要持续引用,才能保存内部的变量

博客的对闭包的理解:
闭包就是能够读取到其他函数的变量的函数,在JavaScript中,只有内部函数才能读取外部函数的
局部变量,因此闭包也可以定义为 "在一个函数内部的函数",所以本质上,闭包是将函数内部与函数
外部沟通起来的一道桥梁

闭包的两个作用:1.读取到函数内部的局部变量;  2.使局部变量不能释放,达到存储局部变量的目的


this

是 JS中的关键字,函数运行时内部自动生成的对象,this只能在函数内调用;
   this 规则:谁调用该函数,this就是那个对象

1.纯粹函数调用,在哪里调用就是指哪个对象:全局函数中this指的是 this global全局对象
2.作为对象的方法,函数可以作为对象的方法调用,this 指的就是该对象
3.作为构造函数(面向对象),通过函数生成一个新的对象, this指的就是这个新的对象

4.apply 与 call
第一个参数就是改变后 调用该函数的对象,第二个参数是传进该函数的参数
test.apply/call(str)
我的理解:让str能调用test的方法


垃圾回收机制,非基本数据类型存放在堆中,占用内存,堆不会被程序自动释放
声明变量a = 对象, 只是声明一个指针地址直线存储该对象的内存空间
每多一个指向同一内存空间的指针地址,该对象的引用计数就会+1
如果代码在运行过程中有一个对象不再被需要,但仍被引用,垃圾回收机制
就不能自动释放这块内存空间,这就是内存泄漏
解决内存泄漏的方法是 解除对该内存地址的引用,将引用他的指针地址设置为null


JavaScript 单线程核心特征:

任务队列(JS单线程所有任务必须排队完成)
JS计算能力很弱如果存在一个耗时较长的任务,后一个任务就必须等待很长时间
让前一个任务完成,所以,如果网络请求他的耗时完全取决于网络状况(Ajax),这不符合js设计逻辑

主线程可以忽略I/O设备,挂起处于等待中的任务,先运行排在后面的任务
等到I/O设备有了返回结果,再回过头把挂起任务执行下去(异步事件)

所有任务分为两种:同步事件 (synchronous)  异步事件(asynchronous)

JS运行机制步骤

1.所有同步任务都在主线程上依次执行,形成(执行栈)
2.主线程之外,存在一个任务队列,只要异步任务有了返回结果,该任务就会被放入
任务队列中
3.执行栈中所有任务执行完毕后,就会访问任务队列,检查队列中有哪些事件,获取
任务队列中最先等待的事件,让该事件进入执行栈,开始执行
4.不断重复第3步

回调函数 callback (事件绑定函数)
 例如:绑定点击事件,当点击事件触发时,JS会调用事件绑定的函数,该函数称为
 事件的回调函数(异步任务必须指定回调函数)
任务队列 先进先出数据结构,排在前面的事件会先被主线程读取,所以如果队列中有
'定时器',定时器未必准时触发,取决于前一个任务队列中的函数执行的事件

栈stack 三种定义 (数据结构 后进先出  数组 push pop)

内存区域
    程序运行时,需要内存空间存放数据,stack栈 和 heap堆
      栈是由结构的,每个区块按照一定顺序取存放,可以明确的知道每个区块的大小,
      heap是没有结构的,数据任意存放,因此栈的调用要快于堆
      每个线程分配一个栈,每个进程分配一个堆,stack是线程独占,heap是线程公用的
      栈是系统自动开辟的自动释放的 堆是程序员手动开辟和释放的


面向对象
    JS没有class ,但是属性property 方法method 又存在于JS中
  1.原始封装模式  模仿函数编写
  2.改进          向函数传参数,返回一个对象
  3.构造函数模式  通过构造函数生成实例对象,它会自动含有constructor属性,指向他的构造函数
                 缺点:对于每一个实例对象,都有某些属性方法是一模一样的
  4.改进原型模式  每一个构造函数都有一个prototype属性,该属性指向另一个对象,所有实例都会继承该prototype指向的对象
    prototype     prototype.isPrototypeOf() :判断构造器原型对象与实例中的__proto__是否指向同一片内存地址
                __proto__是实例对象的属性 构造函数 与 构造器 的原型属性是 prototype


继承

使用子类prototype属性完成继承,等于父类的实例(如果要修改prototype指向的对象一定要修改constructor属性!!)
例如:
    function Animal() {
        this.type = '动物'
    }
    function Dog(name, color) {
        this.name = name;
        this.color = color
    }
    Dog.prototype = new Animal()

    var dog1 = new Dog('小狗', '灰色')

    console.log(dog1.constructor)  //Animal()  原因是constructor该属性 属于prototype里的属性

    Dog.prototype.constructor = Dog;  // prototype属性实现继承的方法在继承完毕后 一定修改constructor属性

    console.log(dog1.constructor)

直接继承父类prototype 必须要有中介 (空对象) 好处:1.几乎不占内存 2.不能继承构造器中的属性(没有构造器)
    我的理解:因为空对象中是没有构造器的,它没有直接的构造器,所以将不能把构造器中的属性传给实例对象,
            而实例对象这个时候是没有构造器的,所以要讲一个构造函数的构造器传给这个实例对象.

例:
function Animal1(){
    }
    Animal1.prototype.type = '动物';
    function Dog1(name, color){
        this.name = name;
        this.color = color
    }
    function Mid(){}
    Mid.prototype = Animal1.prototype;
    Dog1.prototype = new Mid();
    Dog1.prototype.constructor = Dog1;
    var dog2 = new Dog1('小百','白色');
    var animal1 = new Animal1();
    console.log(dog1,dog2)


简易日历中

当函数遇到事件时,因为异步的问题,需要在事件外将this 赋给一个变量,这样才能使事件内获取到事件外的this
var that = this








